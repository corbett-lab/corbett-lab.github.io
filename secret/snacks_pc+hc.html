<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Interactive PCA Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/umap-js@1.4.0/lib/umap-js.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .header {
            background: linear-gradient(45deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .upload-section {
            padding: 30px;
            background: rgba(52, 152, 219, 0.05);
            border-bottom: 1px solid rgba(52, 152, 219, 0.1);
        }
        
        .file-input {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .file-input input[type="file"] {
            padding: 12px;
            border: 2px dashed #3498db;
            border-radius: 10px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .file-input input[type="file"]:hover {
            border-color: #2980b9;
            background: rgba(52, 152, 219, 0.05);
        }
        
        .analyze-btn {
            background: linear-gradient(45deg, #e74c3c, #f39c12);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }
        
        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.4);
        }
        
        .analyze-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .controls-section {
            padding: 20px 30px;
            background: rgba(155, 89, 182, 0.05);
            border-bottom: 1px solid rgba(155, 89, 182, 0.1);
        }
        
        .pc-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: center;
        }
        
        .pc-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .pc-selector label {
            font-weight: 600;
            color: #2c3e50;
            font-size: 14px;
        }
        
        .pc-selector select {
            padding: 8px 12px;
            border: 2px solid #9b59b6;
            border-radius: 8px;
            background: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .pc-selector select:hover {
            border-color: #8e44ad;
            background: rgba(155, 89, 182, 0.05);
        }
        
        .update-plots-btn {
            background: linear-gradient(45deg, #9b59b6, #8e44ad);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(155, 89, 182, 0.3);
        }
        
        .update-plots-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.4);
        }
        
        .plots-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 30px;
            min-height: 600px;
        }
        
        .plot-section {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: transform 0.3s ease;
        }
        
        .plot-section:hover {
            transform: translateY(-5px);
        }
        
        .plot-title {
            background: linear-gradient(45deg, #34495e, #2c3e50);
            color: white;
            padding: 20px;
            margin: 0;
            font-size: 1.3em;
            font-weight: 300;
        }
        
        .plot-content {
            height: 500px;
        }
        
        .stats-section {
            padding: 30px;
            background: rgba(46, 204, 113, 0.05);
            border-top: 1px solid rgba(46, 204, 113, 0.1);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .stats-card {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.08);
            border-left: 5px solid #2ecc71;
        }
        
        .stats-card h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1.2em;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 50px;
            font-size: 18px;
            color: #3498db;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .variance-overview {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .variance-bars {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .variance-bar {
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            padding: 8px;
            min-width: 60px;
            text-align: center;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .variance-bar:hover {
            background: rgba(255,255,255,0.5);
            transform: translateY(-2px);
        }
        
        @media (max-width: 768px) {
            .plots-container {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .pc-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ Enhanced Interactive PCA Analysis</h1>
            <p>Upload your TSV file to explore 5 principal components with interactive navigation</p>
        </div>
        
        <div class="upload-section">
            <div class="file-input">
                <input type="file" id="fileInput" accept=".tsv,.txt" />
                <button class="analyze-btn" onclick="analyzePCA()" id="analyzeBtn" disabled>
                    üöÄ Analyze Data (5 PCs)
                </button>
            </div>
        </div>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            Processing your data and computing 5 principal components...
        </div>
        
        <div class="controls-section" id="controlsSection" style="display: none;">
            <div class="pc-controls">
                <div class="pc-selector">
                    <label>X-Axis (PC)</label>
                    <select id="pcXSelect">
                        <option value="0">PC1</option>
                        <option value="1">PC2</option>
                        <option value="2">PC3</option>
                        <option value="3">PC4</option>
                        <option value="4">PC5</option>
                    </select>
                </div>
                <div class="pc-selector">
                    <label>Y-Axis (PC)</label>
                    <select id="pcYSelect">
                        <option value="0">PC1</option>
                        <option value="1" selected>PC2</option>
                        <option value="2">PC3</option>
                        <option value="3">PC4</option>
                        <option value="4">PC5</option>
                    </select>
                </div>
                <button class="update-plots-btn" onclick="updatePlots()">
                    üîÑ Update Plots
                </button>
            </div>
        </div>
        
        <div class="plots-container" id="plotsContainer" style="display: none;">
            <div class="plot-section">
                <h3 class="plot-title" id="scatterTitle">üìä PCA Scatter Plot</h3>
                <div class="plot-content" id="scatterPlot"></div>
            </div>
            <div class="plot-section">
                <h3 class="plot-title" id="loadingsTitle">üéØ Feature Loadings</h3>
                <div class="plot-content" id="loadingsPlot"></div>
            </div>
        </div>

        <div class="stats-section" id="statsSection" style="display: none;">
            <div class="variance-overview" id="varianceOverview"></div>
            <div class="stats-grid">
                <div class="stats-card">
                    <h3>üìà Current PCs Variance</h3>
                    <div id="varianceStats"></div>
                </div>
                <div class="stats-card">
                    <h3>üîç Top Influencing Features</h3>
                    <div id="featuresStats"></div>
                </div>
                <div class="stats-card">
                    <h3>üå≤ Clustering Info</h3>
                    <div id="clusterStats"></div>
                </div>
                <div class="stats-card">
                    <h3>üìã Data Summary</h3>
                    <div id="dataStats"></div>
                </div>
            </div>

        <div id="clusterContainer" style="display: none; padding: 30px;">
            <div class="plot-section">
                <h3 class="plot-title">üå≥ Hierarchical Clustering Dendrogram</h3>
                <div class="plot-content" id="dendrogramPlot" style="height: 600px;"></div>
            </div>
        </div>

        <div class="plots-container" id="umapContainer" style="display: none;">
            <div class="plot-section" style="grid-column: 1 / -1;">
                <h3 class="plot-title">üó∫Ô∏è UMAP Projection</h3>
                <div class="plot-content" id="umapPlot" style="height: 600px;"></div>
            </div>
        </div>
        
    </div>

    <script>
        let globalPCAResult = null;
        let globalItems = null;
        let globalFeatures = null;
        let globalClusterResult = null;
        let globalNormalizedData = null;
        let globalUMAPResult = null;
        let currentPCX = 0;
        let currentPCY = 1;

        // Enable analyze button when file is selected
        document.getElementById('fileInput').addEventListener('change', function(e) {
            document.getElementById('analyzeBtn').disabled = !e.target.files.length;
        });

        // Auto-load default file on page load
        window.addEventListener('DOMContentLoaded', function() {
            loadDefaultFile();
        });

        function loadDefaultFile() {
            const defaultFileName = 'Grocery Outlet Bargain Martke - Sheet1.tsv';
            
            // Show loading
            document.getElementById('loading').style.display = 'block';
            
            // Fetch the default file
            fetch(defaultFileName)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Default file not found');
                    }
                    return response.text();
                })
                .then(tsvText => {
                    // Parse the TSV
                    Papa.parse(tsvText, {
                        header: true,
                        delimiter: '\t',
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: function(results) {
                            processData(results.data);
                        },
                        error: function(error) {
                            console.error('Error parsing default file:', error);
                            document.getElementById('loading').style.display = 'none';
                        }
                    });
                })
                .catch(error => {
                    console.error('Error loading default file:', error);
                    document.getElementById('loading').style.display = 'none';
                });
        }

        function analyzePCA() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file first!');
                return;
            }

            // Show loading
            document.getElementById('loading').style.display = 'block';
            document.getElementById('controlsSection').style.display = 'none';
            document.getElementById('plotsContainer').style.display = 'none';
            document.getElementById('statsSection').style.display = 'none';

            // Parse TSV file
            Papa.parse(file, {
                header: true,
                delimiter: '\t',
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    processData(results.data);
                },
                error: function(error) {
                    alert('Error reading file: ' + error.message);
                    document.getElementById('loading').style.display = 'none';
                }
            });
        }

        function processData(data) {
            try {
                // Find item column (usually first non-numeric column)
                const headers = Object.keys(data[0]);
                const itemColumn = headers.find(h => 
                    typeof data[0][h] === 'string' || h.toLowerCase().includes('item') || h.toLowerCase().includes('name')
                ) || headers[0];
                
                // Get numeric columns
                const numericColumns = headers.filter(h => h !== itemColumn);
                
                // Extract data matrices
                globalItems = data.map(row => row[itemColumn]);
                globalFeatures = numericColumns;
                const X = data.map(row => numericColumns.map(col => parseFloat(row[col]) || 0));
                
                // Normalize data
                const normalizedX = normalizeMatrix(X);
                globalNormalizedData = normalizedX;
                
                // Perform PCA with 5 components
                globalPCAResult = performPCA(normalizedX, 5);
                
                // Perform hierarchical clustering
                globalClusterResult = performHierarchicalClustering(normalizedX, globalItems);
                
                // Perform UMAP
                globalUMAPResult = performUMAP(normalizedX);
                
                // Create initial plots (PC1 vs PC2)
                updatePlots();
                
                // Create dendrogram
                createDendrogram();
                
                // Create UMAP plot
                createUMAPPlot();
                
                // Show variance overview
                showVarianceOverview();
                
                // Show stats
                showStats(data.length);
                
                // Hide loading and show results
                document.getElementById('loading').style.display = 'none';
                document.getElementById('controlsSection').style.display = 'block';
                document.getElementById('plotsContainer').style.display = 'grid';
                document.getElementById('clusterContainer').style.display = 'grid';
                document.getElementById('umapContainer').style.display = 'grid';
                document.getElementById('statsSection').style.display = 'block';
                
            } catch (error) {
                alert('Error processing data: ' + error.message);
                document.getElementById('loading').style.display = 'none';
            }
        }

        function updatePlots() {
            currentPCX = parseInt(document.getElementById('pcXSelect').value);
            currentPCY = parseInt(document.getElementById('pcYSelect').value);
            
            if (currentPCX === currentPCY) {
                alert('Please select different principal components for X and Y axes!');
                return;
            }
            
            createScatterPlot();
            createLoadingsPlot();
            updateCurrentStats();
        }

        function normalizeMatrix(matrix) {
            const numCols = matrix[0].length;
            const numRows = matrix.length;
            const normalized = [];
            
            for (let col = 0; col < numCols; col++) {
                // Calculate mean and std for this column
                const values = matrix.map(row => row[col]);
                const mean = values.reduce((a, b) => a + b, 0) / numRows;
                const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / numRows;
                const std = Math.sqrt(variance) || 1; // Avoid division by zero
                
                // Normalize column
                for (let row = 0; row < numRows; row++) {
                    if (!normalized[row]) normalized[row] = [];
                    normalized[row][col] = (matrix[row][col] - mean) / std;
                }
            }
            
            return normalized;
        }

        function performPCA(matrix, numComponents) {
            const numRows = matrix.length;
            const numCols = matrix[0].length;
            
            // Calculate covariance matrix
            const covariance = [];
            for (let i = 0; i < numCols; i++) {
                covariance[i] = [];
                for (let j = 0; j < numCols; j++) {
                    let sum = 0;
                    for (let k = 0; k < numRows; k++) {
                        sum += matrix[k][i] * matrix[k][j];
                    }
                    covariance[i][j] = sum / (numRows - 1);
                }
            }
            
            // Perform eigenvalue decomposition using Jacobi method
            const eigen = jacobiEigenvalueDecomposition(covariance);
            
            // Sort eigenvalues and eigenvectors in descending order
            const sortedIndices = eigen.eigenvalues
                .map((val, idx) => ({ val, idx }))
                .sort((a, b) => b.val - a.val)
                .map(item => item.idx);
            
            const sortedEigenvalues = sortedIndices.map(i => eigen.eigenvalues[i]);
            const sortedEigenvectors = sortedIndices.map(i => eigen.eigenvectors[i]);
            
            // Calculate explained variance ratios
            const totalVariance = sortedEigenvalues.reduce((a, b) => a + Math.max(0, b), 0);
            const explainedVariance = sortedEigenvalues
                .slice(0, numComponents)
                .map(val => Math.max(0, val) / totalVariance);
            
            // Get principal components (eigenvectors)
            const components = sortedEigenvectors.slice(0, numComponents);
            
            // Transform data
            const transformedData = [];
            for (let row = 0; row < numRows; row++) {
                transformedData[row] = [];
                for (let pc = 0; pc < numComponents; pc++) {
                    let sum = 0;
                    for (let col = 0; col < numCols; col++) {
                        sum += matrix[row][col] * components[pc][col];
                    }
                    transformedData[row][pc] = sum;
                }
            }
            
            return {
                transformedData,
                components,
                explainedVariance
            };
        }

        function jacobiEigenvalueDecomposition(matrix) {
            const n = matrix.length;
            const A = matrix.map(row => [...row]); // Deep copy
            const V = Array(n).fill().map((_, i) => Array(n).fill(0).map((_, j) => i === j ? 1 : 0)); // Identity matrix
            
            const maxIterations = 1000;
            const tolerance = 1e-10;
            
            for (let iter = 0; iter < maxIterations; iter++) {
                // Find the largest off-diagonal element
                let maxVal = 0;
                let p = 0, q = 1;
                
                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        if (Math.abs(A[i][j]) > maxVal) {
                            maxVal = Math.abs(A[i][j]);
                            p = i;
                            q = j;
                        }
                    }
                }
                
                if (maxVal < tolerance) break;
                
                // Calculate rotation angle
                const theta = 0.5 * Math.atan2(2 * A[p][q], A[q][q] - A[p][p]);
                const cos = Math.cos(theta);
                const sin = Math.sin(theta);
                
                // Apply Jacobi rotation
                const App = A[p][p];
                const Aqq = A[q][q];
                const Apq = A[p][q];
                
                A[p][p] = cos * cos * App + sin * sin * Aqq - 2 * sin * cos * Apq;
                A[q][q] = sin * sin * App + cos * cos * Aqq + 2 * sin * cos * Apq;
                A[p][q] = A[q][p] = 0;
                
                for (let i = 0; i < n; i++) {
                    if (i !== p && i !== q) {
                        const Aip = A[i][p];
                        const Aiq = A[i][q];
                        A[i][p] = A[p][i] = cos * Aip - sin * Aiq;
                        A[i][q] = A[q][i] = sin * Aip + cos * Aiq;
                    }
                    
                    const Vip = V[i][p];
                    const Viq = V[i][q];
                    V[i][p] = cos * Vip - sin * Viq;
                    V[i][q] = sin * Vip + cos * Viq;
                }
            }
            
            // Extract eigenvalues and eigenvectors
            const eigenvalues = Array(n).fill().map((_, i) => A[i][i]);
            const eigenvectors = Array(n).fill().map((_, i) => Array(n).fill().map((_, j) => V[j][i]));
            
            return { eigenvalues, eigenvectors };
        }

        function createScatterPlot() {
            const trace = {
                x: globalPCAResult.transformedData.map(row => row[currentPCX]),
                y: globalPCAResult.transformedData.map(row => row[currentPCY]),
                mode: 'markers',
                type: 'scatter',
                text: globalItems,
                textposition: 'top center',
                marker: {
                    size: 12,
                    color: globalPCAResult.transformedData.map((_, i) => i),
                    colorscale: 'Viridis',
                    line: { width: 2, color: 'white' }
                },
                hovertemplate: `<b>%{text}</b><br>PC${currentPCX + 1}: %{x:.2f}<br>PC${currentPCY + 1}: %{y:.2f}<extra></extra>`
            };

            const layout = {
                title: false,
                xaxis: { 
                    title: `PC${currentPCX + 1} (${(globalPCAResult.explainedVariance[currentPCX] * 100).toFixed(1)}%)`,
                    showgrid: true,
                    gridcolor: '#f0f0f0'
                },
                yaxis: { 
                    title: `PC${currentPCY + 1} (${(globalPCAResult.explainedVariance[currentPCY] * 100).toFixed(1)}%)`,
                    showgrid: true,
                    gridcolor: '#f0f0f0'
                },
                margin: { l: 50, r: 50, t: 30, b: 50 },
                plot_bgcolor: 'rgba(255,255,255,0.9)',
                paper_bgcolor: 'rgba(255,255,255,0)'
            };

            // Update title
            document.getElementById('scatterTitle').textContent = `üìä PC${currentPCX + 1} vs PC${currentPCY + 1} Scatter Plot`;

            Plotly.newPlot('scatterPlot', [trace], layout, {responsive: true});
        }

        function createLoadingsPlot() {
            const points = {
                x: globalPCAResult.components[currentPCX],
                y: globalPCAResult.components[currentPCY],
                mode: 'markers+text',
                type: 'scatter',
                text: globalFeatures,
                textposition: 'top center',
                marker: {
                    size: 8,
                    color: 'red',
                    line: { width: 1, color: 'darkred' }
                },
                hovertemplate: `<b>%{text}</b><br>PC${currentPCX + 1}: %{x:.3f}<br>PC${currentPCY + 1}: %{y:.3f}<extra></extra>`
            };

            const layout = {
                title: false,
                xaxis: { 
                    title: `PC${currentPCX + 1} Loadings`,
                    range: [-1.1, 1.1],
                    showgrid: true,
                    gridcolor: '#f0f0f0',
                    zeroline: true,
                    zerolinecolor: '#888'
                },
                yaxis: { 
                    title: `PC${currentPCY + 1} Loadings`,
                    range: [-1.1, 1.1],
                    showgrid: true,
                    gridcolor: '#f0f0f0',
                    zeroline: true,
                    zerolinecolor: '#888'
                },
                margin: { l: 50, r: 50, t: 30, b: 50 },
                plot_bgcolor: 'rgba(255,255,255,0.9)',
                paper_bgcolor: 'rgba(255,255,255,0)'
            };

            // Update title
            document.getElementById('loadingsTitle').textContent = `üéØ PC${currentPCX + 1} vs PC${currentPCY + 1} Feature Loadings`;

            Plotly.newPlot('loadingsPlot', [points], layout, {responsive: true});
        }

        function showVarianceOverview() {
            const { explainedVariance } = globalPCAResult;
            const cumulativeVariance = explainedVariance.reduce((acc, curr, i) => {
                acc.push(i === 0 ? curr : acc[i-1] + curr);
                return acc;
            }, []);

            const barsHtml = explainedVariance.map((variance, i) => 
                `<div class="variance-bar">
                    <div>PC${i + 1}</div>
                    <div><strong>${(variance * 100).toFixed(1)}%</strong></div>
                </div>`
            ).join('');

            const overviewHtml = `
                <h3 style="margin: 0 0 10px 0;">üìä Explained Variance Overview</h3>
                <p style="margin: 0;">Total variance explained by all 5 PCs: <strong>${(cumulativeVariance[4] * 100).toFixed(1)}%</strong></p>
                <div class="variance-bars">${barsHtml}</div>
            `;

            document.getElementById('varianceOverview').innerHTML = overviewHtml;
        }

        function updateCurrentStats() {
            // Current PCs variance stats
            const varianceHtml = `
                <p><strong>PC${currentPCX + 1}:</strong> ${(globalPCAResult.explainedVariance[currentPCX] * 100).toFixed(1)}%</p>
                <p><strong>PC${currentPCY + 1}:</strong> ${(globalPCAResult.explainedVariance[currentPCY] * 100).toFixed(1)}%</p>
                <p><strong>Combined:</strong> ${((globalPCAResult.explainedVariance[currentPCX] + globalPCAResult.explainedVariance[currentPCY]) * 100).toFixed(1)}%</p>
            `;
            
            // Top features for current PCs
            const pcXFeatures = globalFeatures.map((f, i) => ({ name: f, loading: Math.abs(globalPCAResult.components[currentPCX][i]) }))
                .sort((a, b) => b.loading - a.loading).slice(0, 3);
            const pcYFeatures = globalFeatures.map((f, i) => ({ name: f, loading: Math.abs(globalPCAResult.components[currentPCY][i]) }))
                .sort((a, b) => b.loading - a.loading).slice(0, 3);
            
            const featuresHtml = `
                <p><strong>PC${currentPCX + 1} Top Features:</strong></p>
                <ul>
                    ${pcXFeatures.map(f => `<li>${f.name} (${f.loading.toFixed(3)})</li>`).join('')}
                </ul>
                <p><strong>PC${currentPCY + 1} Top Features:</strong></p>
                <ul>
                    ${pcYFeatures.map(f => `<li>${f.name} (${f.loading.toFixed(3)})</li>`).join('')}
                </ul>
            `;
            
            document.getElementById('varianceStats').innerHTML = varianceHtml;
            document.getElementById('featuresStats').innerHTML = featuresHtml;
        }

        function showStats(numSamples) {
            // Data summary
            const dataHtml = `
                <p><strong>Samples:</strong> ${numSamples}</p>
                <p><strong>Features:</strong> ${globalFeatures.length}</p>
                <p><strong>Principal Components:</strong> 5</p>
                <p><strong>UMAP Components:</strong> 2</p>
                <p><strong>Current View:</strong> PC${currentPCX + 1} vs PC${currentPCY + 1}</p>
            `;
            
            document.getElementById('dataStats').innerHTML = dataHtml;
            
            // Update current stats
            updateCurrentStats();
            
            // Update cluster stats
            updateClusterStats();
        }

        // Hierarchical Clustering Functions
        function performHierarchicalClustering(data, labels) {
            const n = data.length;
            
            // Calculate distance matrix
            const distMatrix = [];
            for (let i = 0; i < n; i++) {
                distMatrix[i] = [];
                for (let j = 0; j < n; j++) {
                    distMatrix[i][j] = euclideanDistance(data[i], data[j]);
                }
            }
            
            // Initialize clusters - each sample is its own cluster
            const clusters = labels.map((label, idx) => ({
                id: idx,
                label: label,
                members: [idx],
                left: null,
                right: null,
                distance: 0,
                size: 1
            }));
            
            const mergeHistory = [];
            let nextClusterId = n;
            
            // Active clusters (not yet merged)
            const activeClusters = [...clusters];
            
            // Perform agglomerative clustering
            while (activeClusters.length > 1) {
                // Find pair of clusters with minimum distance
                let minDist = Infinity;
                let minI = 0, minJ = 1;
                
                for (let i = 0; i < activeClusters.length; i++) {
                    for (let j = i + 1; j < activeClusters.length; j++) {
                        const dist = clusterDistance(
                            activeClusters[i].members,
                            activeClusters[j].members,
                            distMatrix
                        );
                        if (dist < minDist) {
                            minDist = dist;
                            minI = i;
                            minJ = j;
                        }
                    }
                }
                
                // Merge clusters
                const cluster1 = activeClusters[minI];
                const cluster2 = activeClusters[minJ];
                
                const newCluster = {
                    id: nextClusterId++,
                    label: `Cluster ${nextClusterId - n}`,
                    members: [...cluster1.members, ...cluster2.members],
                    left: cluster1,
                    right: cluster2,
                    distance: minDist,
                    size: cluster1.size + cluster2.size
                };
                
                mergeHistory.push({
                    cluster1: cluster1.id,
                    cluster2: cluster2.id,
                    distance: minDist,
                    newCluster: newCluster.id
                });
                
                // Remove merged clusters and add new cluster
                activeClusters.splice(Math.max(minI, minJ), 1);
                activeClusters.splice(Math.min(minI, minJ), 1);
                activeClusters.push(newCluster);
            }
            
            return {
                root: activeClusters[0],
                mergeHistory: mergeHistory,
                originalClusters: clusters
            };
        }
        
        function euclideanDistance(vec1, vec2) {
            let sum = 0;
            for (let i = 0; i < vec1.length; i++) {
                sum += Math.pow(vec1[i] - vec2[i], 2);
            }
            return Math.sqrt(sum);
        }
        
        function clusterDistance(members1, members2, distMatrix) {
            // Average linkage
            let sum = 0;
            let count = 0;
            for (const i of members1) {
                for (const j of members2) {
                    sum += distMatrix[i][j];
                    count++;
                }
            }
            return sum / count;
        }
        
        function createDendrogram() {
            const { root } = globalClusterResult;
            
            // Build dendrogram data structure
            const dendroData = buildDendrogramData(root);
            
            // Create Plotly dendrogram
            const trace = {
                type: 'scatter',
                mode: 'lines+markers',
                x: dendroData.x,
                y: dendroData.y,
                line: {
                    color: '#2c3e50',
                    width: 2
                },
                marker: {
                    color: '#3498db',
                    size: 6
                },
                hoverinfo: 'text',
                text: dendroData.hoverText,
                showlegend: false
            };
            
            
            const layout = {
                title: false,
                xaxis: {
                    title: '',
                    tickmode: 'array',
                    tickvals: dendroData.labelX,
                    ticktext: dendroData.labels,
                    tickangle: -45,
                    showgrid: false,
                    zeroline: false,
                    side: 'bottom',
                    ticks: 'outside',
                    ticklen: 5,
                    tickwidth: 1,
                    tickcolor: '#2c3e50',
                    tickfont: {
                        size: 20,
                        color: '#2c3e50'
                    }
                },
                yaxis: {
                    title: 'Distance',
                    showgrid: true,
                    gridcolor: '#f0f0f0',
                    rangemode: 'tozero'
                },
                margin: { l: 60, r: 50, t: 30, b: 350 },
                plot_bgcolor: 'rgba(255,255,255,0.9)',
                paper_bgcolor: 'rgba(255,255,255,0)',
                hovermode: 'closest'
            };
            
            Plotly.newPlot('dendrogramPlot', [trace], layout, {responsive: true});
        }
        
        function buildDendrogramData(root) {
            const x = [];
            const y = [];
            const hoverText = [];
            const labelX = [];
            const labelY = [];
            const labels = [];
            
            let leafPosition = 0;
            const leafPositions = {};
            
            function traverse(node) {
                if (!node.left && !node.right) {
                    // Leaf node
                    leafPositions[node.id] = leafPosition;
                    labelX.push(leafPosition);
                    labelY.push(0.5);
                    labels.push(node.label);
                    leafPosition++;
                    return leafPosition - 1;
                }
                
                // Internal node
                const leftPos = traverse(node.left);
                const rightPos = traverse(node.right);
                const midPos = (leftPos + rightPos) / 2;
                
                // Draw vertical lines from children to this node's height
                // Left child
                x.push(leftPos, leftPos, null);
                y.push(node.left.distance, node.distance, null);
                hoverText.push('', `Distance: ${node.distance.toFixed(3)}`, '');
                
                // Right child
                x.push(rightPos, rightPos, null);
                y.push(node.right.distance, node.distance, null);
                hoverText.push('', `Distance: ${node.distance.toFixed(3)}`, '');
                
                // Horizontal line connecting children
                x.push(leftPos, rightPos, null);
                y.push(node.distance, node.distance, null);
                hoverText.push(`Distance: ${node.distance.toFixed(3)}`, '', '');
                
                return midPos;
            }
            
            traverse(root);
            
            return { x, y, hoverText, labelX, labelY, labels };
        }
        
        function updateClusterStats() {
            const { root, mergeHistory } = globalClusterResult;
            
            const clusterHtml = `
                <p><strong>Samples:</strong> ${globalItems.length}</p>
                <p><strong>Linkage Method:</strong> Average</p>
                <p><strong>Distance Metric:</strong> Euclidean</p>
                <p><strong>Total Merges:</strong> ${mergeHistory.length}</p>
                <p><strong>Max Distance:</strong> ${root.distance.toFixed(3)}</p>
            `;
            
            document.getElementById('clusterStats').innerHTML = clusterHtml;
        }

        // UMAP Functions
        function performUMAP(data) {
            const umap = new UMAP.UMAP({
                nComponents: 2,
                nNeighbors: 15,
                minDist: 0.1,
                spread: 1.0
            });
            
            const embedding = umap.fit(data);
            
            return {
                embedding: embedding,
                nNeighbors: 15,
                minDist: 0.1
            };
        }
        
        function createUMAPPlot() {
            const trace = {
                x: globalUMAPResult.embedding.map(point => point[0]),
                y: globalUMAPResult.embedding.map(point => point[1]),
                mode: 'markers+text',
                type: 'scatter',
                text: globalItems,
                textposition: 'top center',
                textfont: {
                    size: 8
                },
                marker: {
                    size: 12,
                    color: '#3498db',
                    line: { width: 2, color: 'white' }
                },
                hovertemplate: `<b>%{text}</b><br>UMAP1: %{x:.3f}<br>UMAP2: %{y:.3f}<extra></extra>`
            };

            const layout = {
                title: false,
                xaxis: { 
                    title: 'UMAP Dimension 1',
                    showgrid: true,
                    gridcolor: '#f0f0f0',
                    zeroline: true,
                    zerolinecolor: '#888'
                },
                yaxis: { 
                    title: 'UMAP Dimension 2',
                    showgrid: true,
                    gridcolor: '#f0f0f0',
                    zeroline: true,
                    zerolinecolor: '#888'
                },
                margin: { l: 60, r: 120, t: 30, b: 60 },
                plot_bgcolor: 'rgba(255,255,255,0.9)',
                paper_bgcolor: 'rgba(255,255,255,0)',
                hovermode: 'closest',
                showlegend: false
            };

            Plotly.newPlot('umapPlot', [trace], layout, {responsive: true});
        }

    </script>
</body>
</html>